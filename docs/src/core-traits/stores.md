# Stores & Codecs

The crate separates storage concerns into three traits: `EventStore` for event persistence, `SnapshotStore` for aggregate snapshots, and `Codec` for serialization.

## The `EventStore` Trait

```rust,ignore
pub trait EventStore {
    /// Aggregate identifier type.
    type Id: Clone;

    /// Position type for ordering (e.g., `u64` for global sequence, `()` for unordered)
    type Position: Copy + PartialEq + std::fmt::Debug;

    /// Store-specific error type
    type Error: std::error::Error;

    /// Serialization strategy
    type Codec: Codec;

    /// Metadata type attached to events
    type Metadata;

    fn codec(&self) -> &Self::Codec;

    fn stream_version(
        &self,
        aggregate_kind: &str,
        aggregate_id: &Self::Id,
    ) -> Result<Option<Self::Position>, Self::Error>;

    /// Begin a write transaction with a chosen concurrency strategy.
    fn begin<C: ConcurrencyStrategy>(
        &mut self,
        aggregate_kind: &str,
        aggregate_id: Self::Id,
        expected_version: Option<Self::Position>,
    ) -> Transaction<'_, Self, C>
    where
        Self: Sized;

    /// Load events matching the given filters.
    fn load_events(
        &self,
        filters: &[EventFilter<Self::Id, Self::Position>],
    ) -> Result<Vec<StoredEvent<Self::Id, Self::Position, Self::Metadata>>, Self::Error>;
}
```

## Built-in: `InMemoryEventStore`

For testing and prototyping:

```rust,ignore
use event_sourcing::{InMemoryEventStore, JsonCodec};

// With unit metadata
let store: InMemoryEventStore<String, JsonCodec, ()> = InMemoryEventStore::new(JsonCodec);

// With custom metadata
let store: InMemoryEventStore<String, JsonCodec, MyMetadata> = InMemoryEventStore::new(JsonCodec);
```

Features:
- Uses `u64` positions (global sequence number)
- Events stored in memory (lost on drop)
- Deduplicates overlapping filters when loading

## Transactions

Events are appended within a transaction for atomicity:

```rust,ignore
use event_sourcing::Unchecked;

let mut tx = store.begin::<Unchecked>("account", "ACC-001".to_string(), None);
tx.append(event1, metadata.clone())?;
tx.append(event2, metadata.clone())?;
tx.commit()?; // Events visible only after commit
```

If the transaction is dropped without committing, no events are persisted.

## Event Filters

Control which events to load:

```rust,ignore
// All events of a specific kind (across all aggregates)
EventFilter::for_event("account.deposited")

// All events for a specific aggregate instance
EventFilter::for_aggregate("account.deposited", "account", "ACC-001")

// Events after a position (for incremental loading)
EventFilter::for_event("account.deposited").after(100)
```

## The `Codec` Trait

```rust,ignore
pub trait Codec {
    type Error: std::error::Error;

    fn serialize<E: Serialize>(&self, event: &E) -> Result<Vec<u8>, Self::Error>;
    fn deserialize<E: DeserializeOwned>(&self, data: &[u8]) -> Result<E, Self::Error>;
}
```

## Built-in: `JsonCodec`

Uses `serde_json` for human-readable storage:

```rust,ignore
use event_sourcing::JsonCodec;

let codec = JsonCodec;
```

For production, consider implementing codecs for:
- **Protobuf** — Compact, schema-enforced
- **MessagePack** — Compact, schema-less
- **Avro** — Schema evolution built-in

## The `SnapshotStore` Trait

```rust,ignore
pub trait SnapshotStore {
    type Id;
    type Position;
    type Error: std::error::Error + Send + Sync + 'static;

    fn load(
        &self,
        aggregate_kind: &str,
        aggregate_id: &Self::Id,
    ) -> Result<Option<Snapshot<Self::Position>>, Self::Error>;

    fn should_snapshot(
        &self,
        aggregate_kind: &str,
        aggregate_id: &Self::Id,
        events_since_last_snapshot: u64,
    ) -> bool;

    fn offer_snapshot(
        &mut self,
        aggregate_kind: &str,
        aggregate_id: &Self::Id,
        snapshot: Snapshot<Self::Position>,
        events_since_last_snapshot: u64,
    ) -> Result<(), Self::Error>;
}
```

See [Snapshots](../advanced/snapshots.md) for details.

## The `StoredEvent` Type

Events loaded from the store:

```rust,ignore
pub struct StoredEvent<Id, Pos, M> {
    pub aggregate_kind: String,
    pub aggregate_id: Id,
    pub kind: String,           // Event type (e.g., "account.deposited")
    pub position: Pos,          // Global or stream position
    pub data: Vec<u8>,          // Serialized event payload
    pub metadata: M,            // Store-provided metadata
}
```

## The `PersistableEvent` Type

Events ready to be stored:

```rust,ignore
pub struct PersistableEvent<M> {
    pub kind: String,           // Event type
    pub data: Vec<u8>,          // Serialized payload
    pub metadata: M,            // Caller-provided metadata
}
```

The `SerializableEvent` trait (generated by the derive macro) converts domain events into this form.

## Implementing a Custom Store

See [Custom Stores](../advanced/custom-stores.md) for a guide on implementing `EventStore` for your database.

## Next

[The Aggregate Derive](../derive-macros/aggregate-derive.md) — Reducing boilerplate with macros
