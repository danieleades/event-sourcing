# Stores & Codecs

The crate separates storage concerns into three traits: `EventStore` for event persistence, `SnapshotStore` for aggregate snapshots, and `Codec` for serialization.

## The `EventStore` Trait

```rust,ignore
pub trait EventStore {
    /// Position type for ordering (e.g., `u64` for global sequence, `()` for unordered)
    type Position;

    /// Store-specific error type
    type Error: std::error::Error;

    /// Serialization strategy
    type Codec: Codec;

    /// Metadata type attached to events
    type Metadata;

    /// Begin a write transaction
    fn begin(&mut self, aggregate_kind: &str, aggregate_id: &str)
        -> Transaction<'_, Self>;

    /// Load events matching the given filters
    fn load_events(&self, filters: &[EventFilter<Self::Position>])
        -> Result<Vec<StoredEvent<Self::Position, Self::Metadata>>, Self::Error>;
}
```

## Built-in: `InMemoryEventStore`

For testing and prototyping:

```rust,ignore
use event_sourcing::{InMemoryEventStore, JsonCodec};

// With unit metadata
let store: InMemoryEventStore<JsonCodec, ()> = InMemoryEventStore::new(JsonCodec);

// With custom metadata
let store: InMemoryEventStore<JsonCodec, MyMetadata> = InMemoryEventStore::new(JsonCodec);
```

Features:
- Uses `u64` positions (global sequence number)
- Thread-safe via internal mutability
- Events stored in memory (lost on drop)
- Deduplicates overlapping filters when loading

## Transactions

Events are appended within a transaction for atomicity:

```rust,ignore
let mut tx = store.begin("account", "ACC-001");
tx.append(event1, metadata.clone())?;
tx.append(event2, metadata.clone())?;
tx.commit()?; // Events visible only after commit
```

If the transaction is dropped without committing, no events are persisted.

## Event Filters

Control which events to load:

```rust,ignore
// All events of a specific kind (across all aggregates)
EventFilter::for_event("account.deposited")

// All events for a specific aggregate instance
EventFilter::for_aggregate("account.deposited", "account", "ACC-001")

// Events after a position (for incremental loading)
EventFilter::for_event("account.deposited").after(100)
```

## The `Codec` Trait

```rust,ignore
pub trait Codec {
    type Error: std::error::Error;

    fn serialize<E: Serialize>(&self, event: &E) -> Result<Vec<u8>, Self::Error>;
    fn deserialize<E: DeserializeOwned>(&self, data: &[u8]) -> Result<E, Self::Error>;
}
```

## Built-in: `JsonCodec`

Uses `serde_json` for human-readable storage:

```rust,ignore
use event_sourcing::JsonCodec;

let codec = JsonCodec;
```

For production, consider implementing codecs for:
- **Protobuf** — Compact, schema-enforced
- **MessagePack** — Compact, schema-less
- **Avro** — Schema evolution built-in

## The `SnapshotStore` Trait

```rust,ignore
pub trait SnapshotStore<A: Aggregate> {
    type Error: std::error::Error;
    type Position;

    /// Load the latest snapshot for an aggregate
    fn load(&self, aggregate_kind: &str, aggregate_id: &A::Id)
        -> Result<Option<Snapshot<A, Self::Position>>, Self::Error>;

    /// Offer a snapshot (the store decides whether to save)
    fn offer_snapshot(
        &mut self,
        aggregate_kind: &str,
        aggregate_id: &A::Id,
        aggregate: &A,
        position: Self::Position,
        events_since_last_snapshot: usize,
    ) -> Result<(), Self::Error>;
}
```

See [Snapshots](../advanced/snapshots.md) for details.

## The `StoredEvent` Type

Events loaded from the store:

```rust,ignore
pub struct StoredEvent<Pos, M> {
    pub aggregate_kind: String,
    pub aggregate_id: String,
    pub kind: String,           // Event type (e.g., "account.deposited")
    pub position: Pos,          // Global or stream position
    pub data: Vec<u8>,          // Serialized event payload
    pub metadata: M,            // Store-provided metadata
}
```

## The `PersistableEvent` Type

Events ready to be stored:

```rust,ignore
pub struct PersistableEvent<M> {
    pub kind: String,           // Event type
    pub data: Vec<u8>,          // Serialized payload
    pub metadata: M,            // Caller-provided metadata
}
```

The `SerializableEvent` trait (generated by the derive macro) converts domain events into this form.

## Implementing a Custom Store

See [Custom Stores](../advanced/custom-stores.md) for a guide on implementing `EventStore` for your database.

## Next

[The Aggregate Derive](../derive-macros/aggregate-derive.md) — Reducing boilerplate with macros
