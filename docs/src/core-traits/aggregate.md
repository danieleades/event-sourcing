# Aggregates

An **aggregate** is a cluster of domain objects treated as a single unit for data changes. In event sourcing, aggregates rebuild their state by replaying events and validate commands to produce new events.

## The `Aggregate` Trait

```rust,ignore
pub trait Aggregate: Default + Sized {
    /// Unique type identifier (e.g., "account", "order")
    const KIND: &'static str;

    /// Sum type of all events this aggregate can produce
    type Event: ProjectionEvent + SerializableEvent;

    /// Error type for command validation failures
    type Error;

    /// Identifier type for this aggregate
    type Id;

    /// Apply an event to mutate state
    fn apply(&mut self, event: &Self::Event);
}
```

Most of this is generated by `#[derive(Aggregate)]`. You focus on the behavior.

## Snapshots and `SnapshotableAggregate`

Snapshots are opt-in. If you enable snapshots (via `SnapshotRepository`), the aggregate state must
be serializable so it can be persisted and restored.

```rust,ignore
pub trait SnapshotableAggregate: Aggregate + Serialize + DeserializeOwned {}
```

## The `Apply<E>` Trait

When using `#[derive(Aggregate)]`, implement `Apply<E>` for each event type:

```rust,ignore
pub trait Apply<E> {
    fn apply(&mut self, event: &E);
}
```

This is where state mutation happens:

```rust,ignore
impl Apply<FundsDeposited> for Account {
    fn apply(&mut self, event: &FundsDeposited) {
        self.balance += event.amount;
    }
}

impl Apply<FundsWithdrawn> for Account {
    fn apply(&mut self, event: &FundsWithdrawn) {
        self.balance -= event.amount;
    }
}
```

**Key rules:**

- `apply` must be **infallible** — events represent facts that already happened
- `apply` must be **deterministic** — same events produce same state
- Keep `apply` simple — complex logic belongs in command handlers

## Event Replay

```d2
shape: sequence_diagram

Store: Event Store
Agg: Account (Default)

Agg: "balance = 0" {shape: text}
Store -> Agg: "apply(FundsDeposited { amount: 100 })"
Agg: "balance = 100" {shape: text}
Store -> Agg: "apply(FundsWithdrawn { amount: 30 })"
Agg: "balance = 70" {shape: text}
Store -> Agg: "apply(FundsDeposited { amount: 50 })"
Agg: "balance = 120" {shape: text}
```

The aggregate starts in its `Default` state. Each event is applied in order. The final state matches what would exist if you had executed all the original commands.

## Loading Aggregates

Use `AggregateBuilder` to load an aggregate's current state:

```rust,ignore
let account: Account = repository
    .aggregate_builder()
    .load(&account_id)?;

println!("Current balance: {}", account.balance);
```

On `Repository` this replays all events for that aggregate ID.
On `SnapshotRepository` it loads a snapshot first (when present) and replays only the delta.

## Complete Example

```rust,ignore
use event_sourcing::{Aggregate, Apply, DomainEvent};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FundsDeposited {
    pub amount: i64,
}

impl DomainEvent for FundsDeposited {
    const KIND: &'static str = "account.deposited";
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FundsWithdrawn {
    pub amount: i64,
}

impl DomainEvent for FundsWithdrawn {
    const KIND: &'static str = "account.withdrawn";
}

#[derive(Debug, Default, Serialize, Deserialize, Aggregate)]
#[aggregate(id = String, error = AccountError, events(FundsDeposited, FundsWithdrawn))]
pub struct Account {
    balance: i64,
}

impl Apply<FundsDeposited> for Account {
    fn apply(&mut self, event: &FundsDeposited) {
        self.balance += event.amount;
    }
}

impl Apply<FundsWithdrawn> for Account {
    fn apply(&mut self, event: &FundsWithdrawn) {
        self.balance -= event.amount;
    }
}
```

## Next

[Domain Events](domain-event.md) — Defining events as first-class types
